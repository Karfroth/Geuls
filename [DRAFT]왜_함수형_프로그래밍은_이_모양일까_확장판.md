# ì™œ í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì€ ì´ ëª¨ì–‘ì¼ê¹Œ? - í™•ì¥íŒ

## ì„œë¬¸ (í™•ì¥íŒ)
ë³¸ ê¸€ì€ ì§€ì¸ìœ¼ë¡œë¶€í„° [ì™œ í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì€ ì´ ëª¨ì–‘ì¼ê¹Œ?](2022-11-20-ì™œ_í•¨ìˆ˜í˜•_í”„ë¡œê·¸ë˜ë°ì€_ì´_ëª¨ì–‘ì¼ê¹Œ.md)ì— ëŒ€í•œ í”¼ë“œë°±ì„ ë°›ê³  ì‘ì„±í•˜ëŠ” í™•ì¥íŒì´ë‹¤. ê¸°ì¡´ ê¸€ì˜ ë¶„ëŸ‰ì€ ë‚´ìš©ì„ í¬ê²Œ ë°”ê¾¸ì§€ ì•ŠëŠ” ì„ ì—ì„œ ì½ê¸° ì¢‹ë„ë¡ ìˆ˜ì •í•˜ê³ , ë§ˆì§€ë§‰ ë¶€ë¶„ì—ì„œ íƒ€ì…ì— ëŒ€í•œ ë¶€ë¶„ì´ë‚˜ Continuationì— ê´€ë ¨ëœ ë¶€ë¶„ì„ ì¡°ê¸ˆ ë” í™•ì¥í–ˆë‹¤. ì´ë ‡ê²Œ í•˜ëŠ” ê°€ì¥ í° ì´ìœ ëŠ” ë¬¼ë¡  í”¼ë“œë°±ì„ ë°›ì•˜ê¸° ë•Œë¬¸ì´ì§€ë§Œ, ì´ì „ ê¸€ì„ ì„œë‘ë¥´ë“¯ ë§ˆë¬´ë¦¬ ì§€ì€ ê²ƒ ê°™ì€ ëŠë‚Œì´ ì•„ì‰½ê¸° ë•Œë¬¸ì´ê¸°ë„ í•˜ë‹¤.

ì²˜ìŒ í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì„ ë°°ìš¸ ë•Œë§Œ í•´ë„ ì™œ í• ë‹¹ì´ ì•„ë‹ˆë¼ ë°”ì¸ë”©ì¸ì§€, ì™œ ë¶ˆë³€ì¸ì§€, ì™œ 1ê¸‰ ì‹œë¯¼ìœ¼ë¡œì„œì˜ í•¨ìˆ˜ê°€ ê·¸ë ‡ê²Œ ì¤‘ìš”í•œì§€ì— ëŒ€í•´ ê¶ê¸ˆí–ˆë˜ ê¸°ì–µì´ ë‚œë‹¤. ì´ëŸ¬í•œ ê²ƒì„ ê³µë¶€í•˜ëŠ”ë° ìˆì–´ì„œ ì»¤ë®¤ë‹ˆí‹°ì—ì„œ ë§ì€ ê²ƒì„ ë°›ì€ ë§Œí¼, ì´ ê¸€ë¡œ ë‚˜ë„ ì»¤ë®¤ë‹ˆí‹°ì— í™˜ì›í•  ìˆ˜ ìˆìœ¼ë©´ ì¢‹ê² ë‹¤ëŠ” ìƒê°ì„ í•œë‹¤.

## ì„œë¬¸ (ì›ë¬¸)
ë³¸ê²©ì ìœ¼ë¡œ ê°œë°œì„ ì—…ìœ¼ë¡œ ì‚¼ê³ ì ê²°ì‹¬í–ˆë˜ ì¦ˆìŒ, Courseraì˜ Scala ì½”ìŠ¤ë¡œ ì¢€ ë” ë³¸ê²©ì ì¸ í”„ë¡œê·¸ë˜ë°ì— ì…ë¬¸í•˜ê²Œ ëœ ê¸°ì–µì´ ë‚œë‹¤. (ë‹¹ì‹œ ê°•ì¢ŒëŠ” 2022-12-15 í˜„ì¬ [Functional Programming in Scala Specialization](https://www.coursera.org/specializations/scala)ìœ¼ë¡œ í™•ì¥ë˜ì—ˆë‹¤) ë‹¹ì‹œì—ëŠ” Rì´ë‚˜ Python, Ruby ì •ë„ì˜ ì–¸ì–´ë§Œ ì¡°ê¸ˆ ë§Œì ¸ë³¸ ê²ƒì´ ì „ë¶€ì˜€ë˜ì§€ë¼ ë”°ë¼ê°€ê¸° ì¡°ê¸ˆ ë²„ê²ê¸°ëŠ” í–ˆìœ¼ë‚˜ ê³„ì† í•˜ë‹¤ë³´ë‹ˆ ìƒê°ë³´ë‹¤ ì¬ë¯¸ìˆì–´ì„œ ëê¹Œì§€ ë§ˆì¹  ìˆ˜ ìˆì—ˆê³ , ë‚˜ì¤‘ì—ëŠ” Scalaë¥¼ ì‚¬ìš©í•˜ëŠ” íšŒì‚¬ì— ì·¨ì§ê¹Œì§€ ì„±ê³µì ìœ¼ë¡œ í•  ìˆ˜ ìˆì—ˆë‹¤. í”„ë¡œê·¸ë˜ë°ì´ ì„±ê²©ì—ë„ ì˜ ë§ê³  Scalaë„ ì¬ë¯¸ìˆê³  ì§ì¥ë„ ì¡ì•˜ìœ¼ë‹ˆ ëª¨ë“  ê²ƒì´ ì˜ í’€ë ¸ë‹¤. í•˜ì§€ë§Œ ê·¸ ë‹¹ì‹œë¶€í„° ìµœê·¼ê¹Œì§€(ëŒ€ëµ 6ë…„ ì´ìƒ) ë‚´ ë¨¸ë¦¬ ì†ì„ ë– ë‚˜ì§€ ì•Šì€ ê¶ê¸ˆì¦ì´ í•˜ë‚˜ ìˆìœ¼ë‹ˆ, ê·¸ê²ƒì€ ë°”ë¡œ "í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì´ë€ ë¬´ì—‡ì¼ê¹Œ?"ë¼ëŠ” ê²ƒì´ë‹¤. (ë¬¼ë¡  ë‹¹ì‹œì—ëŠ” ê·¸ëƒ¥ ê¶ê¸ˆì¦ ì •ë„ë¡œ ê·¸ëƒ¥ ì¸í„°ë„·ë§Œ ì¡°ê¸ˆ ë’¤ì ¸ë³´ëŠ” ì •ë„ì˜€ì§€ë§Œ, ëª¨ ì»¤ë®¤ë‹ˆí‹° ì‚¬ì´íŠ¸ì—ì„œ ëª¨ ìœ ì €ì™€ í‚¤ë°°ë¥¼ ë– ë³´ê³ ì ì˜ìƒë„ ì°¾ì•„ë³´ê³  í˜ì´í¼ë„ ì½ì–´ë³´ëŠ” ë“± ë” ì—´ì‹¬íˆ ê³µë¶€í•˜ê²Œ ë˜ê¸´ í–ˆë‹¤. Keyboard-battle driven studyë¼ê³  í•˜ë„ë¡ í•˜ì.)

í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°, í˜¹ì€ í•¨ìˆ˜í˜• íŒ¨ëŸ¬ë‹¤ì„ì´ ì—¬ëŸ¬ ë¶„ì•¼ì—ì„œ ìœ í–‰ì„ íƒ€ê¸° ì‹œì‘í•˜ë©´ì„œ ì´ì— ëŒ€í•œ ì •ë³´ë¥¼ ì°¾ì•„ë³´ê¸°ëŠ” ì ì  ë” ì‰¬ì›Œì§€ê³  ìˆë‹¤. í•˜ì§€ë§Œ ìƒê° ì™¸ë¡œ í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì— ëŒ€í•œ ëª…í™•í•œ ì •ì˜ë¥¼ ì°¾ì•„ë³´ê¸°ê°€ ì‰½ì§€ëŠ” ì•Šì€ë°, ë§ˆì´í´ í¬ê±°ìŠ¤ì™€ í¬ë¦¬ìŠ¤ í•˜ìš°ì €ì˜ ì €ì„œ `í´ë¡œì € í”„ë¡œê·¸ë˜ë°ì˜ ì¦ê±°ì›€`ì—ì„œëŠ” ë‹¤ìŒê³¼ ê°™ì€ êµ¬ì ˆë„ ë‚˜ì˜¨ë‹¤.

> ë¬´ì—‡ì´ í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì¸ê°€? í‹€ë ¸ë‹¤.

ì´ ë§ì´ ë¬´ì—‡ì„ ì˜ë¯¸í•˜ëŠ”ê°€? ê·¸ë§Œí¼ í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì— ëŒ€í•œ ì •ì˜ê°€ ì œëŒ€ë¡œ ì´ë¤„ì§€ì§€ ì•Šê³  ìˆë‹¤ê³  ë³¼ ìˆ˜ ìˆì§€ ì•Šì„ê¹Œ? í•˜ì§€ë§Œ ì´ë ‡ê²Œ ì •ì˜ê°€ ì–´ë µë‹¤ëŠ” ê²ƒê³¼ ë³„ê°œë¡œ ì»¤ë®¤ë‹ˆí‹°ì—ì„œëŠ” ëŒ€ê°œ í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì„ ë‹¤ìŒê³¼ ê°™ì€ íŠ¹ì§•ìœ¼ë¡œ ì •ì˜í•˜ê³ ëŠ” í•œë‹¤.

- 1ê¸‰ ì‹œë¯¼ìœ¼ë¡œì„œì˜ í•¨ìˆ˜ (First Class Function)
- ê³ ì°¨ í•¨ìˆ˜ (Higher Order Function)
- ìˆœìˆ˜ í•¨ìˆ˜ (Pure Function)
- ë¶ˆë³€ (Immutability)
- ë³€ìˆ˜ í• ë‹¹ ì—†ìŒ (No Assignment)
- ì°¸ì¡° íˆ¬ëª…ì„± (Referential Transparency)

ì—¬ê¸°ì— ì•ˆì „í•œ íƒ€ì… ì‹œìŠ¤í…œì´ë‚˜ Maybe/Optionê³¼ ê°™ì€ í‘í„°(Functor)/ëª¨ë‚˜ë“œ(Monad) ê°œë…ì„ ë”í•´ í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì— ëŒ€í•´ ì´ì•¼ê¸°í•˜ëŠ” ê²ƒì„ ë§¤ìš° í”í•˜ê²Œ ì°¾ì•„ë³¼ ìˆ˜ ìˆë‹¤. ë¶„ëª… í‹€ë ¸ë‹¤ê³  í•˜ì§€ëŠ” ì•Šê² ë‹¤. í•˜ì§€ë§Œ ì´ ëª¨ë“  ê²ƒë“¤ì„ ì¢…í•©í–ˆì„ ë•Œ í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì´ ë¬´ì—‡ì¸ì§€ ì •ì˜í•œë‹¤ê³  ì •ë§ ì´ì•¼ê¸°í•  ìˆ˜ ìˆì„ê¹Œ?

ì •ì˜ì˜ ë¬¸ì œì™€ ë³„ê°œë¡œ, í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì„ ê¹Šê²Œ ê³µë¶€í•˜ëŠ” ì‚¬ëŒë“¤ ì‚¬ì´ì—ì„œëŠ” ë¶€ìˆ˜ íš¨ê³¼ë¥¼ ì•ˆì „í•˜ê²Œ ë‹¤ë£¨ëŠ” ê²ƒ, ê·¸ë¦¬ê³  ê·¸ë¥¼ ìœ„í•´ ëª¨ë‚˜ë“œë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì„ ì–´ë µì§€ ì•Šê²Œ ì°¾ì•„ë³¼ ìˆ˜ ìˆëŠ”ë°, ì´ëŸ¬í•œ ë‹´ë¡ ì€ í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì— ì‚´ì§ ê´€ì‹¬ì„ ê°–ëŠ” ì‚¬ëŒë“¤ì—ê²Œ ì´ëŸ¬í•œ ì˜¤í•´ë¥¼ ë‚³ê³ ëŠ” í•œë‹¤.

- í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì€ ì–´ë µë‹¤ (Moand, Functor ë“±ë“± ë²”ì£¼ë¡ ì„ ì ê·¹ì ìœ¼ë¡œ í™œìš©í•˜ë¯€ë¡œ)
- í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì€ ë¶€ìˆ˜ íš¨ê³¼(Side Effect)ë¥¼ ë‹¤ë£¨ëŠ” ë° íŠ¹í™”ë˜ì—ˆë‹¤ (ìˆœìˆ˜ í•¨ìˆ˜ê°€ ê¶Œì¥ë˜ë©° ë¶€ìˆ˜ íš¨ê³¼ëŠ” ë³„ë„ë¡œ ê´€ë¦¬í•˜ê²Œ í•˜ë¯€ë¡œ)
- í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì€ íƒ€ì…ì— ê´€í•œ ê²ƒì´ë‹¤
- 2010 ~ 2020ë…„ëŒ€ì— ë‹¤ë¥¸ ì–¸ì–´ë“¤ì´ í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì„ ë°›ì•„ë“¤ì´ëŠ” ê²ƒì€ ê²°êµ­ í”„ë¡œê·¸ë˜ë¨¸ë“¤ì„ ìœ ì¹˜í•˜ê¸° ìœ„í•œ ìˆ˜ë‹¨ì´ë©° ì´ëŠ” ë‹¤ë¥¸ í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë° ì»¤ë®¤ë‹ˆí‹°ì— ë¶€ì •ì ì¸ ì˜í–¥ì„ ì¤„ ê²ƒì´ë‹¤ (í•„ìê°€ ì§„ì§œë¡œ ë´¤ë‹¤)

ì•ì„œ ë§í–ˆë“¯, ì´ëŸ¬í•œ ëª¨ë“  ê²ƒë“¤ì€ ì‚¬ì‹¤ ì˜¤í•´ì— ë¶ˆê³¼í•˜ë‹¤ëŠ” ê²ƒì„ ê°•ì¡°í•˜ê³  ì‹¶ë‹¤. í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì˜ í•µì‹¬ì€ ë§¤ìš° ê°„ë‹¨í•˜ë‹¤.

ì‚¬ì‹¤ ì˜ë¬¸ ìœ„í‚¤í˜ë””ì•„ì˜ [Functional programming í•­ëª©](https://en.wikipedia.org/wiki/Functional_programming)ì´ ì²« ë¬¸ë‹¨ì´ í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì˜ ëª…í™•í•œ ì •ì˜ë¥¼ ë³´ì—¬ì¤€ë‹¤

> In computer science, functional programming is a programming paradigm where programs are constructed by applying and composing functions. It is a declarative programming paradigm in which function definitions are trees of expressions that map values to other values, rather than a sequence of imperative statements which update the running state of the program.

> ì»´í“¨í„° ê³¼í•™ì—ì„œ í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì€ í•¨ìˆ˜ì˜ ì¡°í•©ê³¼ ì ìš©ì„ í†µí•´ í”„ë¡œê·¸ë¨ì„ êµ¬ì„±í•˜ëŠ” í”„ë¡œê·¸ë˜ë° íŒ¨ëŸ¬ë‹¤ì„ì´ë‹¤. ì´ëŠ” í”„ë¡œê·¸ë¨ì˜ ìƒíƒœë¥¼ ì—…ë°ì´íŠ¸í•˜ëŠ” ì¼ë ¨ì˜ ëª…ë ¹í˜• êµ¬ë¬¸ì´ ì•„ë‹Œ, í•¨ìˆ˜ì˜ ì •ì˜ê°€ ê°’ì„ ë‹¤ë¥¸ ê°’ìœ¼ë¡œ ë§¤í•‘í•˜ëŠ” í‘œí˜„ì‹ íŠ¸ë¦¬ì¸ ì„ ì–¸í˜• í”„ë¡œê·¸ë˜ë° íŒ¨ëŸ¬ë‹¤ì„ì´ë‹¤.

ì´ ì •ì˜ëŠ” í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì˜ í•µì‹¬ ë¶€ë¶„ì„ ì •ì˜í•˜ì§€ë§Œ, ì •ì‘ ì‹¤ì œ í”„ë¡œê·¸ë˜ë°ì—ì„œ ì´ê²ƒì´ ì–´ë–»ê²Œ ì ìš©ë˜ì—ˆëŠ”ì§€ ì°¾ì•„ë³´ê¸°ëŠ” ì‰½ì§€ ì•Šë‹¤.

ì´ ê¸€ì˜ ëª©ì ì€ ë§¤ìš° ëª…í™•í•˜ë‹¤: í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì˜ í•µì‹¬ì— ëŒ€í•œ ëª…í™•í•œ ì •ì˜ë¥¼ ë‚´ë¦¬ëŠ” ê²ƒ. í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì˜ íŠ¹ì§•ì€ ì •ì˜ë¥¼ ë‚´ë¦¬ëŠ” ë„ì¤‘ ë„ì¶œë  ìˆ˜ëŠ” ìˆìœ¼ë‚˜ ì£¼ìš” ì£¼ì œëŠ” ì•„ë‹ˆë©°, í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì˜ ì¥ì ì€ ì¸í„°ë„·ì´ë‚˜ ì„œì ìœ¼ë¡œ ì´ë¯¸ ì˜ ë‚˜ì™€ìˆìœ¼ë¯€ë¡œ ì´ ê¸€ì—ì„œ ë‹¤ë£¨ì§€ ì•ŠëŠ”ë‹¤.

## í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì˜ ì •ì˜

ì´ ê¸€ì—ì„œ ë‚´ë¦¬ëŠ” í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì˜ ì •ì˜ëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤.

> í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë° í˜¹ì€ íŒ¨ëŸ¬ë‹¤ì„ì€ ìˆ˜í•™ì  í‘œí˜„ì‹ìœ¼ë¡œ êµ¬ì„±ëœ í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ëŠ” ê²ƒì„ ì˜ë¯¸í•œë‹¤.

## ìˆ˜í•™ì  í‘œí˜„ì‹ì—ì„œ í”„ë¡œê·¸ë˜ë° ì–¸ì–´ë¡œ

í”„ë¡œê·¸ë˜ë°, ê·¸ë¦¬ê³  ê·¸ ê¸°ë°˜ì´ ëœ ìˆ˜í•™ê³¼ ë…¼ë¦¬í•™ì´ ì—­ì‚¬ì ìœ¼ë¡œ ì„œë°© ì„¸ê³„ì—ì„œ ë°œë‹¬ë˜ì—ˆë‹¤. ë”°ë¼ì„œ, ì•ˆíƒ€ê¹Œìš´ ì‚¬ì‹¤ì´ë‚˜, í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì˜ ì •ì˜ë¥¼ ì´í•´í•˜ê¸° ìœ„í•´ì„œëŠ” ì¼ë‹¨ ì„œë°© ì„¸ê³„ì—ì„œì˜ ìˆ˜í•™ ì‹ì— ëŒ€í•´ì„œ ì•Œì•„ë´ì•¼ í•œë‹¤.

ì•„ë˜ì— ì˜ì–´ë¡œ ëœ ê°„ë‹¨í•œ ìˆ˜í•™ì  í‘œí˜„ì´ ìˆë‹¤.

> $3 + x = 12$

ì´ ë°©ì •ì‹ì€ ê·¸ ìì²´ë¡œ ë¬´ì–¸ê°€ë¥¼ í‘œí˜„í•˜ì§€ë§Œ ì´ê²ƒì´ ì°¸ì¸ì§€ ê±°ì§“ì¸ì§€ëŠ” ì•„ì§ ì•Œ ìˆ˜ ì—†ë‹¤. ê·¸ë ‡ë‹¤ë©´ ë‹¨ì„œë¥¼ ì£¼ë©´ ì–´ë–¨ê¹Œ?

> $3 + x = 12$ $where$ $x = 9$

ì´ ìˆ˜í•™ í‘œí˜„ì‹ ì½ê³  ì´í•´í•˜ëŠ” ê²ƒì€ ê·¸ë¦¬ ì–´ë µì§€ ì•Šë‹¤. $x$ê°€ 9ì¼ ë•Œ(where), $x + 3 = 12$ë¼ëŠ” ìˆ˜í•™ í‘œí˜„ì‹ì€ ì°¸ì´ë‹¤. ê°„ë‹¨í•˜ì§€ ì•Šì€ê°€? ì¤‘ìš”í•œ ì ì€, ì´ ìˆ˜í•™ í‘œí˜„ì‹ì„ ì‘ì„±í•˜ëŠ” ë‹¤ë¥¸ ë°©ë²•ì´ ìˆë‹¤ëŠ” ê²ƒì´ë‹¤. `let`ê³¼ `in`ìœ¼ë¡œ `where` ë¶€ë¶„ì„ ì•ìœ¼ë¡œ ì˜®ê²¨ì˜¤ëŠ” ê²ƒì´ë‹¤.

> $let$ $x = 9$ $in$ $3 + x = 12$

ì–´ë”˜ê°€ ê¸°ì‹œê°ì´ ë“¤ì§€ ì•ŠëŠ”ê°€? ì¤„ ë°”ê¿ˆìœ¼ë¡œ ì¡°ê¸ˆë§Œ ë³€í˜•ì„ ì¤˜ë³´ì.

```fsharp
let x = 9 in
3 + x = 12
```

ì´ë ‡ê²Œ ì¤„ ë°”ê¿ˆê¹Œì§€ ì ìš©í•œ ì½”ë“œëŠ” ì´ì œ ëŒ€ë¶€ë¶„ì˜ ë…ìë“¤ì—ê²Œ ì¡°ê¸ˆ ë” ì½ê¸° í¸í•  ê²ƒì´ë‹¤. Javascriptë‚˜ Rustì™€ ë¹„ìŠ·í•´ë³´ì´ì§€ ì•ŠëŠ”ê°€? ì‚¬ì‹¤ ìœ„ì˜ ì½”ë“œëŠ” ì‹¤ì œë¡œ ë™ì‘í•˜ëŠ” ì½”ë“œë¡œ, ML(Meta Language)ì— ì˜í–¥ì„ ë°›ì€ ê±°ì˜ í˜„ëŒ€ í”„ë¡œê·¸ë˜ë° ì–¸ì–´ ëŒ€ë¶€ë¶„(OCaml, F#, Haskell)ì—ì„œ ë™ì‘í•œë‹¤. (ML ê³„ì—´ ì–¸ì–´ì—ì„œ `=`ì€ ë‹¤ë¥¸ ì–¸ì–´ì˜ `==`ì™€ ê°™ì´ ë™ì‘í•œë‹¤. ë”°ë¼ì„œ ìœ„ ì‹ì˜ ê²°ê³¼ê°’ì€ `true`ë‹¤)

ë…ìì˜ ì²« ML(Meta Language) ì½”ë“œ ì‘ì„±ì„ ì¶•í•˜í•˜ëŠ” ë°”ë‹¤.

ìœ„ì˜ ì½”ë“œ, í˜¹ì€ ìˆ˜í•™ í‘œí˜„ì‹ì´ ì‚¬ì‹¤ ìœ„í‚¤í˜ë””ì•„ì—ì„œ ì´ì•¼ê¸°í•œ "ìˆ˜í•™ì  í‘œí˜„ì‹"ì´ë©°, ë™ì‘í•˜ëŠ” í•¨ìˆ˜í˜• í”„ë¡œê·¸ë¨ì€ ì‚¬ì‹¤ ì´ ìˆ˜í•™ì  í‘œí˜„ì‹ì´ ê±°ëŒ€í•´ì§„ ê²ƒì— ë¶ˆê³¼í•˜ë‹¤.

ì´ëŸ¬í•œ ìˆ˜í•™ì  í‘œí˜„ì‹ì˜ ì»´í“¨í„° í”„ë¡œê·¸ë˜ë°ì—ì˜ ì ìš©ì€ Peter Landinì˜ 1966ë…„ í˜ì´í¼, `The next 700 programming languages`ì—ì„œ ISWIMì´ë¼ëŠ” ì–¸ì–´ë¡œ ì²˜ìŒ ì†Œê°œë˜ì—ˆë‹¤. ISWIMì€ ì´í›„ ìˆ˜ë§ì€ í•¨ìˆ˜í˜• ì–¸ì–´ë“¤ì— ì˜í–¥ì„ ì£¼ê²Œ ë˜ëŠ”ë°, ê·¸ ì–¸ì–´ë“¤ ì¤‘ì—ëŠ” MLê³¼ HOPEë“±ì´ ìˆìœ¼ë©°, ì´ ì–¸ì–´ë“¤ì€ ì´í›„ OCaml, F#, Haskell ë“±ì˜ ì–¸ì–´ì— ë‹¤ì‹œ ì˜í–¥ì„ ì£¼ê²Œ ëœë‹¤.

### í‘œí˜„ì‹ ëœ¯ì–´ë³´ê¸°

`let ... in ...` í˜¹ì€ `... where ...`ë¡œ í‘œí˜„ëœ í‘œí˜„ì‹ì€ ëŒë‹¤ ëŒ€ìˆ˜(Lambda Calculus)ì˜ í‘œí˜„ì‹ìœ¼ë¡œ ë‹¤ì‹œ í‘œí˜„ë  ìˆ˜ ìˆë‹¤.

> $(\lambda x.3 + x = 12)$ $9$

ì´ ê¸€ì€ ëŒë‹¤ ëŒ€ìˆ˜ì— ê´€í•œ ê¸€ì€ ì•„ë‹ˆë¯€ë¡œ ë¬¸ë²•ì— ëŒ€í•œ ìì„¸í•œ ì„¤ëª…ì€ ìƒëµí•˜ë‚˜, ìœ„ì˜ ëŒë‹¤ ëŒ€ìˆ˜ í‘œí˜„ì‹ì„ ëŒ€ë¶€ë¶„ì˜ ë…ìì—ê²Œ ìµìˆ™í• (ìµìˆ™...í•˜ì‹œì£ ?) ìë°”ìŠ¤í¬ë¦½íŠ¸ ë¬¸ë²•ìœ¼ë¡œ ë‹¤ì‹œ ì‘ì„±í•´ë³´ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤.

```javascript
((x) => 3 + x === 12)(9) // true
```

`let ... in ...` í‘œí˜„ì‹ì—ì„œëŠ” ë¶„ëª… ë³€ìˆ˜ë¥¼ xì— í• ë‹¹í–ˆë˜ ê²ƒ ê°™ì€ë°, ìë°”ìŠ¤í¬ë¦½íŠ¸ë¡œ ì˜®ê²¨ë³´ë‹ˆ ë³€ìˆ˜ í• ë‹¹ì€ ì˜¨ë°ê°„ë° ì—†ê³  í•¨ìˆ˜ë¥¼ ì„ ì–¸í•˜ê³  ë°”ë¡œ ì¸ìë¥¼ ë„£ëŠ” í‘œí˜„ì‹ë§Œ ë‚¨ì•˜ë‹¤. ì´ê²Œ ë¬´ìŠ¨ ì˜ë¯¸ì¸ê°€? ì´ ì‹ì€ ë„ˆë¬´ ê°„ë‹¨í•˜ë‹ˆ ì´í•´ë¥¼ ìœ„í•´ ì‹ì„ ì•„ì£¼ ì¡°ê¸ˆë§Œ ë” ë³µì¡í•˜ê²Œ ë§Œë“¤ì–´ë³´ì.

> $x + y = 12$ $where$ $y = x * 3$ $where$ $x = 3$

(ìˆ˜í•™ì  í‘œí˜„ì‹ìœ¼ë¡œ ë³´ë©´ ì´ìƒí•  ìˆ˜ë„ ìˆì§€ë§Œ, ISWIMì—ì„œëŠ” í—ˆìš©ë˜ëŠ” ë¬¸ë²•ì´ë‹¤ - where expressionì€ main expressionê³¼ where clauseë¡œ êµ¬ì„±ë˜ë©°, ì¤‘ì²©ì´ ê°€ëŠ¥í•˜ë‹¤.)

```ocaml
let x = 3 in
let y = x * 3 in
x + y = 12
```

```javascript
(
  (x) =>
  ((y) => 
    x + y === 12
  )(x * 3)
)(3)
```

ì´ í‘œí˜„ì‹ì—ì„œ ì•Œ ìˆ˜ ìˆëŠ” ì‚¬ì‹¤ì€ ë¬´ì—‡ì¼ê¹Œ?

í•¨ìˆ˜ê°€ í˜¸ì¶œë  ë•Œ ì¢…ì† ë³€ìˆ˜ê°€ ì´ë¯¸ ì£¼ì–´ì¡Œë‹¤. ê·¸ë ‡ë‹¤ë©´ ì—¬ê¸°ì„œ ë¬¸ì œ, í•œ ìˆ˜í•™ í•¨ìˆ˜ì˜ ë‚´ë¶€ì—ì„œ ì¢…ì† ë³€ìˆ˜ì˜ ê°’ì€ ë°”ë€” ìˆ˜ ìˆì„ê¹Œ, ì—†ì„ê¹Œ? ë‹µì€ "ë°”ë€” ìˆ˜ ì—†ë‹¤"ë‹¤. ìˆ˜í•™ì ìœ¼ë¡œ ì¢…ì† ë³€ìˆ˜ì˜ ê°’ì„ ë°”ê¿€ ë°©ë²•ë”°ìœ„ëŠ” ì¡´ì¬í•˜ì§€ ì•Šìœ¼ë‹ˆ, í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì—ì„œë„ ê·¸ê²ƒì€ ë¶ˆê°€ëŠ¥í•˜ë‹¤. ë”°ë¼ì„œ í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì—ì„œ ë‹¤ë£¨ëŠ” ëª¨ë“  ìë£Œí˜•ì€ ê¸°ë³¸ì ìœ¼ë¡œ ë¶ˆë³€ ì„±ì§ˆì„ ë„ê²Œ ëœë‹¤. 

ë‹¤ë¥¸ ì£¼ì œë¡œëŠ” í• ë‹¹ì— ê´€í•œ ê²ƒì´ ìˆë‹¤. í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì— ëŒ€í•œ ê¸€ì„ ì½ë‹¤ë³´ë©´ í•­ìƒ ë³€ìˆ˜ "í• ë‹¹"ì´ ì—†ë‹¤ëŠ” ì´ì•¼ê¸°ë¥¼ í•œë‹¤. ë¬¸ë²•ìœ¼ë¡œ ë³´ê¸°ì—ëŠ” ë¶„ëª… ë³€ìˆ˜ í• ë‹¹ì¸ë° ê·¸ê²Œ ì•„ë‹ˆë¼ê³  í•˜ë‹ˆ, ì´ê²Œ ë¬´ìŠ¨ ì•„ë²„ì§€ë¥¼ ì•„ë²„ì§€ë¼ ë¶€ë¥´ì§€ ëª»í•˜ëŠ” ìƒí™©ì´ë€ ë§ì¸ê°€? í•˜ì§€ë§Œ ìœ„ì˜ í‘œí˜„ì‹ì„ ë³´ë©´ ì´ì— ëŒ€í•œ ì„¤ëª…ì´ ê°€ëŠ¥í•˜ë‹¤. ìš°ë¦¬ê°€ ì‘ì„±í•˜ëŠ” ì½”ë“œëŠ” ì‚¬ì‹¤ í•¨ìˆ˜ì˜ ì—°ì‡„ë©°, ë³€ìˆ˜ í• ë‹¹ì„ í•œë‹¤ê³  ìƒê°í•œ ëª¨ë“  ë¬¸ë²•ì€ ì‚¬ì‹¤ ë‚´ë¶€ì— ì„ ì–¸í•œ ë‹¤ë¥¸ í•¨ìˆ˜ì— ì¸ìë¥¼ ë„˜ê¸°ëŠ” ê²ƒì´ë‹¤. ë”°ë¼ì„œ ì´ í•¨ìˆ˜ë“¤ì„ ìˆ˜í•™ì ìœ¼ë¡œ ì ‘ê·¼í–ˆì„ ë•Œ, ìš°ë¦¬ê°€ ë³´ëŠ” ë³€ìˆ˜ëŠ” ì—„ë°€íˆ ë§í•´ ì¢…ì† ë³€ìˆ˜(bound variable)ê°€ ëœë‹¤. Bound variable? ê·¸ë ‡ë‹¤, í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì— ëŒ€í•œ ê¸€ì—ì„œ ì´ì•¼ê¸°í•˜ëŠ” ê·¸ ë°”ì¸ë”©ì´ ë°”ë¡œ í•¨ìˆ˜ì— ì¢…ì† ë³€ìˆ˜ë¡œ ë„£ëŠ”ë‹¤ëŠ” ì´ì•¼ê¸°ë‹¤. ì´ë¯¸ ê³„ì‚°í•œ ê°’ì„ ë‹¤ë¥¸ í•¨ìˆ˜ì— ì¸ìë¡œ ë„˜ê¸°ëŠ” ìƒí™©ì´ë‹ˆ "ì¬í• ë‹¹"ì´ ë¶ˆê°€ëŠ¥ í•œ ì´ìœ ë„ ì´ê²ƒìœ¼ë¡œ ì„¤ëª…í•  ìˆ˜ ìˆë‹¤. í•˜ì§€ë§Œ ì´ ê²½ìš°ëŠ” ì–´ë–¨ê¹Œ?

```ocaml
let x = 3 in
let y = x * 3 in
let x = y + 1 in
x + y = 19
```

ìœ„ ì½”ë“œì—ì„œ xëŠ” ì¬í• ë‹¹ëœ ê²ƒìœ¼ë¡œ ë³´ì¸ë‹¤. ì •ë§ ê·¸ëŸ´ê¹Œ? Javascriptë¡œ ì½”ë“œë¥¼ ë°”ê¿”ë³´ë©´ ì•„ë˜ì™€ ê°™ì´ ë‚˜ì˜¨ë‹¤.

```javascript
(
  (x) =>
  ((y) =>
    ((x) => 
      x + y === 19
    )(y + 1)
  )(x * 3)
)(3)
```

ë¬´ì—‡ì´ ë³´ì´ëŠ”ê°€? ë‚´ë¶€ì˜ í•¨ìˆ˜ê°€ `x`ë¼ëŠ” ë¬¸ìë¥¼ ë‹¤ì‹œ ì¢…ì† ë³€ìˆ˜ë¡œ í™œìš©í•˜ë©´ì„œ, ìµœìƒìœ„ì˜ `x`ë¥¼ ë®ì–´ì”Œì› ë‹¤. ì´ëŸ° ê²½ìš°ë¥¼ ì„€ë„ì‰ì´ë¼ ë¶€ë¥´ëŠ”ë°, ì¬í• ë‹¹ì²˜ëŸ¼ ë³´ì´ì§€ë§Œ ì‚¬ì‹¤ ì¬í• ë‹¹ì€ ì•„ë‹ˆë©°, `x`ëŠ” ì™¸ë¶€ ì»¨í…ìŠ¤íŠ¸ì—ì„œ ì—¬ì „íˆ ì¡´ì¬í•œë‹¤.

ì •ì˜ê°€ ì˜¤ë‹ˆ íŠ¹ì§•ì´ ì˜¨ë‹¤. ê°„ë‹¨í•˜ì§€ ì•Šì€ê°€?

### ì‹¤ì œ ì„¸ê³„ì—ì„œì˜ í™œìš©

ì´ëŸ¬í•œ ìˆ˜í•™ì  í‘œí˜„ì‹ì´ ì‹¤ì œ ì„¸ê³„ì—ì„œëŠ” ì–´ë–»ê²Œ í™œìš©ë˜ê³  ìˆì„ê¹Œ? ê°€ì¥ ë¨¼ì €, ì•ì„œ ì–¸ê¸‰í–ˆë“¯ MLì—ì„œ ì˜í–¥ì„ ë°›ì€ ëª¨ë“  ì–¸ì–´ëŠ” ê·¸ ê¸°ë³¸ ë¬¸ë²•ì´ ìœ„ì—ì„œ í‘œí˜„í•œ `let ... in ...`ìœ¼ë¡œ ì´ë£¨ì–´ì ¸ ìˆë‹¤.

ì¡°ê¸ˆ ë” ë„ë¦¬ ì“°ì´ëŠ” ì˜ˆë¡œëŠ” Reactive Programmingì—ì„œ í”íˆ ë³¼ ìˆ˜ ìˆëŠ” pipe í•¨ìˆ˜ë¥¼ ë“¤ ìˆ˜ ìˆë‹¤. RxJS ê³µì‹ ë¬¸ì„œì˜ Operationsë¥¼ ë³´ë©´ [Piping](https://rxjs.dev/guide/operators#piping)ì´ë€ í•­ëª©ì´ ìˆë‹¤. ì²« ë²ˆì§¸ Javascript í‘œí˜„ì‹ì„ ë‘ ë²ˆì§¸ í‘œí˜„ì‹ìœ¼ë¡œ ë‹¤ì‹œ ì“¸ ìˆ˜ ìˆê²Œ í•´ì£¼ëŠ” ê°„ë‹¨í•œ í•¨ìˆ˜ë‹¤.

```javascript
op4()(op3()(op2()(op1()(obs))))
```

```javascript
obs.pipe(op1(), op2(), op3(), op4());
/* ì´ ì‹ì€ ë‹¤ìŒê³¼ ê°™ì´ ë°”ê¿€ ìˆ˜ ìˆë‹¤
  obs.pipe(
    a => op1()(a)
  , b => op2()(b)
  , c => op3()(c)
  , d => op4()(d)
  )
*/
```

ì—¬ê¸°ì„œ ì²« ë²ˆì¨° í•¨ìˆ˜ë¥¼ Javascriptì˜ ìµëª… í•¨ìˆ˜ì™€ `let ... in...` í‘œí˜„ì‹ìœ¼ë¡œ ë‹¤ì‹œ ì‘ì„±í•´ë³´ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤.

```javascript
((a) =>
  ((b) =>
    ((c) => 
      ((d) =>
        op4()(d)
      )(op3()(c))
    )(op2()(b))
  )(op1()(a))
)(obs)
// ğŸ˜±
```

```ocaml
let a = obs in
let b = op1 () (a) in
let c = op2 () (b) in
let d = op3 () (c) in
op4 () (d)
```

pipe í•¨ìˆ˜ì™€ ìˆ˜í•™ì‹ ì‚¬ì´ì˜ ì—°ê³„ê°€ ë³´ì´ì§€ ì•ŠëŠ”ê°€?

## Continuation

## ë” ì•ˆì „í•œ í”„ë¡œê·¸ë¨ì„ í–¥í•´

### Curry-Howard-Lambek Correspondence

### íƒ€ì… ì¶”ë¡ 

### ì‹¤ìˆ˜ë¥¼ ì¤„ì´ì

### ë¶€ìˆ˜ íš¨ê³¼ ê´€ë¦¬

# ì°¸ê³ ìë£Œ
- Bartosz Milewski (Aug 24, 2019). Category Theory for Programmers
- Burstall R.M, MacQueen D.B, Sannella D.T. (1980) Hope: An Experimental Applicative Language. Conference Record of the 1980 LISP Conference, Stanford University, pp. 136-143.
- J. McCarthy (Sept 1958). An Algebraic Language for the Manipulation of Symbolic Expressions. MIT AI Lab., AI Memo No. 1, Cambridge, 
- Landin, P. J. (March 1966). "The Next 700 Programming Languages". Communications of the ACM. Association for Computing Machinery. 9 (3): 157â€“165. doi:10.1145/365230.365257. S2CID 13409665.
- Scott Wlaschin (Jan 21 2013). [Understanding continuations](https://fsharpforfunandprofit.com/posts/computation-expressions-continuations/)
- Turner, D.A. (2013). Some History of Functional Programming Languages. In: Loidl, HW., PeÃ±a, R. (eds) Trends in Functional Programming. TFP 2012. Lecture Notes in Computer Science, vol 7829. Springer, Berlin, Heidelberg. https://doi.org/10.1007/978-3-642-40447-4_1
